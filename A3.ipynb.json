{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "book1 = open(r\"pg103.txt\").read()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'T'"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "book1[1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "#book2 = open(r\"pg18857.txt\").read()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "#book3 = open(r\"1268-0.txt\").read()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "#allBooks = book1+book2+book3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "allBooks = book1[:10000]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "10000"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(allBooks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'\\ufeff'"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "allBooks[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "str"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(allBooks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "8000.0"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(allBooks)*0.8"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "traindata = allBooks[:int(len(allBooks)*0.8)]\n",
    "testdata = allBooks[int(len(allBooks)*0.8):]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "vocab = set(allBooks)\n",
    "vocab_size = len(vocab)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "str"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "type(allBooks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "char2index = {w: i for i, w in enumerate(vocab)}\n",
    "index2char = {i: w for i, w in enumerate(vocab)}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "74"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(set(allBooks))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "10000"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(allBooks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "encode_char = []\n",
    "for char in allBooks:\n",
    "    v = np.zeros((len(vocab),1))\n",
    "    v[char2index[char]] = 1\n",
    "    encode_char.append(v)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "10000"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(encode_char)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1.])"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum(encode_char[320])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [1.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.],\n",
       "       [0.]])"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "encode_char[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "74"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(encode_char[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "traindata = encode_char[:int(len(encode_char)*0.8)]\n",
    "testdata = encode_char[int(len(encode_char)*0.8):]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from numpy.random import randn\n",
    "\n",
    "class RNN:\n",
    "  # A many-to-one Vanilla Recurrent Neural Network.\n",
    "\n",
    "  def __init__(self, input_size, output_size, hidden_size=64):\n",
    "        \n",
    "    self.input_size = input_size\n",
    "    self.output_size = output_size\n",
    "    \n",
    "    # Weights\n",
    "    self.Whh = randn(hidden_size, hidden_size) / 1000\n",
    "    self.Wxh = randn(hidden_size, input_size) / 1000\n",
    "    self.Why = randn(output_size, hidden_size) / 1000\n",
    "\n",
    "    # Biases\n",
    "    self.bh = np.zeros((hidden_size, 1))\n",
    "    self.by = np.zeros((output_size, 1))\n",
    "    \n",
    "   # hidden_size, whh, wxh, why, bh, by\n",
    "    \n",
    "  def testConstructor(self, hidden_size, whh, wxh, why, bh, by):\n",
    "    # Weights\n",
    "    self.Whh = whh\n",
    "    self.Wxh = wxh\n",
    "    self.Why = why\n",
    "\n",
    "    # Biases\n",
    "    self.bh = bh\n",
    "    self.by = by\n",
    "    \n",
    "    if whh.shape != (hidden_size, hidden_size):\n",
    "        raise ValueError(\"whh wrong size\")\n",
    "    \n",
    "    print(wxh)\n",
    "    print(hidden_size)\n",
    "    print(wxh.shape)\n",
    "    print(f'self.input_size is {self.input_size}')\n",
    "    if wxh.shape != (hidden_size, self.input_size):\n",
    "        raise ValueError(\"wxh wrong size\")\n",
    "    \n",
    "    if why.shape != (self.output_size, hidden_size):\n",
    "        raise ValueError(\"why wrong size\")\n",
    "    \n",
    "    if bh.shape != (hidden_size, 1):\n",
    "        raise ValueError(\"bh wrong size\")\n",
    "    \n",
    "    if by.shape != (self.output_size, 1):\n",
    "        raise ValueError(\"by wrong size\")\n",
    "    \n",
    "    \n",
    "  def forward(self, inputs):\n",
    "    '''\n",
    "    Perform a forward pass of the RNN using the given inputs.\n",
    "    Returns the final output and hidden state.\n",
    "    - inputs is an array of one hot vectors with shape (input_size, 1).\n",
    "    '''\n",
    "    h = np.zeros((self.Whh.shape[0], 1))\n",
    "\n",
    "    self.last_inputs = inputs\n",
    "    self.last_hs = { 0: h }\n",
    "\n",
    "    # Perform each step of the RNN\n",
    "    for i, x in enumerate(inputs):\n",
    "      h = np.tanh(self.Wxh @ x + self.Whh @ h + self.bh)\n",
    "      self.last_hs[i + 1] = h\n",
    "\n",
    "    # Compute the output\n",
    "    y = self.Why @ h + self.by\n",
    "\n",
    "    return y, h\n",
    "\n",
    "  def backprop(self, d_y, learn_rate=2e-2):\n",
    "    '''\n",
    "    Perform a backward pass of the RNN.\n",
    "    - d_y (dL/dy) has shape (output_size, 1).\n",
    "    - learn_rate is a float.\n",
    "    '''\n",
    "    n = len(self.last_inputs)\n",
    "\n",
    "    # Calculate dL/dWhy and dL/dby.\n",
    "    d_Why = d_y @ self.last_hs[n].T\n",
    "    d_by = d_y\n",
    "\n",
    "    # Initialize dL/dWhh, dL/dWxh, and dL/dbh to zero.\n",
    "    d_Whh = np.zeros(self.Whh.shape)\n",
    "    d_Wxh = np.zeros(self.Wxh.shape)\n",
    "    d_bh = np.zeros(self.bh.shape)\n",
    "\n",
    "    # Calculate dL/dh for the last h.\n",
    "    # dL/dh = dL/dy * dy/dh\n",
    "    d_h = self.Why.T @ d_y\n",
    "\n",
    "    # Backpropagate through time.\n",
    "    for t in reversed(range(n)):\n",
    "      # An intermediate value: dL/dh * (1 - h^2)\n",
    "      temp = ((1 - self.last_hs[t + 1] ** 2) * d_h)\n",
    "\n",
    "      # dL/db = dL/dh * (1 - h^2)\n",
    "      d_bh += temp\n",
    "\n",
    "      # dL/dWhh = dL/dh * (1 - h^2) * h_{t-1}\n",
    "      d_Whh += temp @ self.last_hs[t].T\n",
    "\n",
    "      # dL/dWxh = dL/dh * (1 - h^2) * x\n",
    "      d_Wxh += temp @ self.last_inputs[t].T\n",
    "\n",
    "      # Next dL/dh = dL/dh * (1 - h^2) * Whh\n",
    "      d_h = self.Whh @ temp\n",
    "\n",
    "    # Clip to prevent exploding gradients.\n",
    "    for d in [d_Wxh, d_Whh, d_Why, d_bh, d_by]:\n",
    "      np.clip(d, -1, 1, out=d)\n",
    "\n",
    "    # Update weights and biases using gradient descent.\n",
    "    self.Whh -= learn_rate * d_Whh\n",
    "    self.Wxh -= learn_rate * d_Wxh\n",
    "    self.Why -= learn_rate * d_Why\n",
    "    self.bh -= learn_rate * d_bh\n",
    "    self.by -= learn_rate * d_by"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import random\n",
    "\n",
    "def createInputs(text):\n",
    "  '''\n",
    "  Returns an array of one-hot vectors representing the words in the input text string.\n",
    "  - text is a string\n",
    "  - Each one-hot vector has shape (vocab_size, 1)\n",
    "  '''\n",
    "  inputs = []\n",
    "  for w in text:\n",
    "    v = np.zeros((vocab_size, 1))\n",
    "    v[word_to_idx[w]] = 1\n",
    "    inputs.append(v)\n",
    "  return inputs\n",
    "\n",
    "def softmax(xs):\n",
    "  # Applies the Softmax Function to the input array.\n",
    "  return np.exp(xs) / sum(np.exp(xs))\n",
    "\n",
    "# Initialize our RNN!\n",
    "# rnn = RNN(vocab_size, 2)\n",
    "\n",
    "def processData(data, backprop=True):\n",
    "  '''\n",
    "  Returns the RNN's loss and accuracy for the given data.\n",
    "  - data is a dictionary mapping text to True or False.\n",
    "  - backprop determines if the backward phase should be run.\n",
    "  '''\n",
    "  #items = list(data.items())\n",
    "  items = data\n",
    "  random.shuffle(items)\n",
    "\n",
    "  loss = 0\n",
    "  num_correct = 0\n",
    "\n",
    "  for x, y in items:\n",
    "    inputs = createInputs(x)\n",
    "    target = int(y)\n",
    "\n",
    "    # Forward\n",
    "    out, _ = rnn.forward(inputs)\n",
    "    probs = softmax(out)\n",
    "\n",
    "    # Calculate loss / accuracy\n",
    "    loss -= np.log(probs[target])\n",
    "    num_correct += int(np.argmax(probs) == target)\n",
    "\n",
    "    if backprop:\n",
    "      # Build dL/dy\n",
    "      d_L_d_y = probs\n",
    "      d_L_d_y[target] -= 1\n",
    "\n",
    "      # Backward\n",
    "      rnn.backprop(d_L_d_y)\n",
    "\n",
    "  return loss / len(data), num_correct / len(data)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "def testRnnForwardProp():\n",
    "    input_size=2\n",
    "    output_size=2\n",
    "    hidden_size = 3\n",
    "    \n",
    "    Rnn = RNN(input_size, output_size)\n",
    "    print(f'rnn.input_size{Rnn.input_size}')\n",
    "    whh = np.asarray([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\n",
    "    wxh = np.asarray([[0.1, 0.2], [0.4, 0.5], [0.7, 0.8]])\n",
    "    why = np.asarray([[0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\n",
    "\n",
    "    bh = np.asarray([[0.1], [0.4], [0.7]])\n",
    "    by = np.asarray([[0.4], [0.7]])\n",
    "    print(wxh.shape)\n",
    "    Rnn.testConstructor(hidden_size, whh, wxh, why, bh, by)\n",
    "   # print(rnn.Whh)\n",
    "    print(len(wxh))\n",
    "    print(len(wxh[0]))\n",
    "def testRnnBackwardProp():\n",
    "    pass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "rnn.input_size2\n",
      "(3, 2)\n",
      "[[0.1 0.2]\n",
      " [0.4 0.5]\n",
      " [0.7 0.8]]\n",
      "3\n",
      "(3, 2)\n",
      "self.input_size is 2\n",
      "3\n",
      "2\n"
     ]
    }
   ],
   "source": [
    "testRnnForwardProp()\n",
    "# wxh.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "74"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(traindata[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "too many values to unpack (expected 2)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-28-2cb47f4fde21>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;31m# Training loop\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mepoch\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m1000\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m   \u001b[0mtrain_loss\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtrain_acc\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mprocessData\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtraindata\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      4\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m   \u001b[0;32mif\u001b[0m \u001b[0mepoch\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0;36m100\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m99\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-24-7bd2415c6e6c>\u001b[0m in \u001b[0;36mprocessData\u001b[0;34m(data, backprop)\u001b[0m\n\u001b[1;32m     35\u001b[0m   \u001b[0mnum_correct\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     36\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 37\u001b[0;31m   \u001b[0;32mfor\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mitems\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     38\u001b[0m     \u001b[0minputs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcreateInputs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     39\u001b[0m     \u001b[0mtarget\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0my\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mValueError\u001b[0m: too many values to unpack (expected 2)"
     ]
    }
   ],
   "source": [
    "# Training loop\n",
    "for epoch in range(1000):\n",
    "  train_loss, train_acc = processData(traindata)\n",
    "\n",
    "  if epoch % 100 == 99:\n",
    "    print('--- Epoch %d' % (epoch + 1))\n",
    "    print('Train:\\tLoss %.3f | Accuracy: %.3f' % (train_loss, train_acc))\n",
    "\n",
    "    test_loss, test_acc = processData(testdata, backprop=False)\n",
    "    print('Test:\\tLoss %.3f | Accuracy: %.3f' % (test_loss, test_acc))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "learning_rate = 0.0001    \n",
    "nepoch = 25               \n",
    "T = 50                   # length of sequence\n",
    "hidden_dim = 100         \n",
    "output_dim = 1\n",
    "\n",
    "bptt_truncate = 5\n",
    "min_clip_value = -10\n",
    "max_clip_value = 10"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "U = np.random.uniform(0, 1, (hidden_dim, T))\n",
    "W = np.random.uniform(0, 1, (hidden_dim, hidden_dim))\n",
    "V = np.random.uniform(0, 1, (output_dim, hidden_dim))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for epoch in range(nepoch):\n",
    "    # check loss on train\n",
    "    loss = 0.0\n",
    "    \n",
    "    # do a forward pass to get prediction\n",
    "    for i in range(Y.shape[0]):\n",
    "        x, y = X[i], Y[i]                    # get input, output values of each record\n",
    "        prev_s = np.zeros((hidden_dim, 1))   # here, prev-s is the value of the previous activation of hidden layer; which is initialized as all zeroes\n",
    "        for t in range(T):\n",
    "            new_input = np.zeros(x.shape)    # we then do a forward pass for every timestep in the sequence\n",
    "            new_input[t] = x[t]              # for this, we define a single input for that timestep\n",
    "            mulu = np.dot(U, new_input)\n",
    "            mulw = np.dot(W, prev_s)\n",
    "            add = mulw + mulu\n",
    "            s = sigmoid(add)\n",
    "            mulv = np.dot(V, s)\n",
    "            prev_s = s\n",
    "\n",
    "    # calculate error \n",
    "        loss_per_record = (y - mulv)**2 / 2\n",
    "        loss += loss_per_record\n",
    "    loss = loss / float(y.shape[0])\n",
    "    \n",
    "     # check loss on val\n",
    "    val_loss = 0.0\n",
    "    for i in range(Y_val.shape[0]):\n",
    "        x, y = X_val[i], Y_val[i]\n",
    "        prev_s = np.zeros((hidden_dim, 1))\n",
    "        for t in range(T):\n",
    "            new_input = np.zeros(x.shape)\n",
    "            new_input[t] = x[t]\n",
    "            mulu = np.dot(U, new_input)\n",
    "            mulw = np.dot(W, prev_s)\n",
    "            add = mulw + mulu\n",
    "            s = sigmoid(add)\n",
    "            mulv = np.dot(V, s)\n",
    "            prev_s = s\n",
    "\n",
    "        loss_per_record = (y - mulv)**2 / 2\n",
    "        val_loss += loss_per_record\n",
    "    val_loss = val_loss / float(y.shape[0])\n",
    "\n",
    "    print('Epoch: ', epoch + 1, ', Loss: ', loss, ', Val Loss: ', val_loss)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "## initialize parameters\n",
    "class RNNNumpy():\n",
    "    def __init__(self, word_dim, hidden_dim = 100, bptt_truncate = 4):\n",
    "        # assign instance variable\n",
    "        self.word_dim = word_dim\n",
    "        self.hidden_dim = hidden_dim\n",
    "        self.bptt_truncate = bptt_truncate\n",
    "        # random initiate the parameters\n",
    "        self.U = np.random.uniform(-np.sqrt(1./word_dim), np.sqrt(1./word_dim), (hidden_dim, word_dim))\n",
    "        self.V = np.random.uniform(-np.sqrt(1./hidden_dim), np.sqrt(1./hidden_dim), (word_dim, hidden_dim))\n",
    "        self.W = np.random.uniform(-np.sqrt(1./hidden_dim), np.sqrt(1./hidden_dim), (hidden_dim, hidden_dim))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "## 3. BPTT\n",
    "'''\n",
    "1. we nudge the parameters into a direction that reduces the error. the direction is given by the gradient of the loss: \\frac{\\partial L}{\\partial U}, \n",
    "\\frac{\\partial L}{\\partial V}, \\frac{\\partial L}{\\partial W}\n",
    "2. we also need learning rate: which indicated how big of a step we want to make in each direction\n",
    "Q: how to optimize SGD using batching, parallelism and adaptive learning rates.\n",
    "\n",
    "RNN BPTT: because the parameters are shared by all time steps in the network, the gradient at each output depends not only on the calculations of the\n",
    "current time step, but also the previous time steps.\n",
    "'''\n",
    "\n",
    "def bptt(self, x, y):\n",
    "    T = len(y)\n",
    "    # perform forward propagation\n",
    "    o, s = self.forward_propagation(x)\n",
    "    # we will accumulate the gradients in these variables\n",
    "    dLdU = np.zeros(self.U.shape)\n",
    "    dLdV = np.zeros(self.V.shape)\n",
    "    dLdW = np.zeros(self.W.shape)\n",
    "    delta_o = o\n",
    "    delta_o[np.arange(len(y)), y] -= 1   # it is y_hat - y\n",
    "    # for each output backwards ...\n",
    "    for t in np.arange(T):\n",
    "        dLdV += np.outer(delta_o[t], s[t].T)    # at time step t, shape is word_dim * hidden_dim\n",
    "        # initial delta calculation\n",
    "        delta_t = self.V.T.dot(delta_o[t]) * (1 - (s[t] ^ 2))\n",
    "        # backpropagation through time (for at most self.bptt_truncate steps)\n",
    "        # given time step t, go back from time step t, to t-1, t-2, ...\n",
    "        for bptt_step in np.arange(max(0, t-self.bptt_truncate), t+1)[::-1]:\n",
    "            # print(\"Backprogation step t=%d bptt step=%d\" %(t, bptt_step))\n",
    "            dLdW += np.outer(delta_t, s[bptt_step - 1])\n",
    "            dLdU[:, x[bptt_step]] += delta_t\n",
    "            # update delta for next step\n",
    "            dleta_t = self.W.T.dot(delta_t) * (1 - s[bptt_step-1]^2)\n",
    "    return [dLdU, dLdV, dLdW]\n",
    "\n",
    "RNNNumpy.bptt = bptt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "## 4. SGD implementation\n",
    "'''\n",
    "two step:\n",
    "1. calculate the gradients and perform the updates for one batch\n",
    "2. loop through the training set and adjust the learning rate\n",
    "'''\n",
    "### 4.1. perform one step of SGD\n",
    "def numpy_sgd_step(self, x, y, learning_rate):\n",
    "    dLdU, dLdV, dLdW = self.bptt(x, y)\n",
    "    self.U -= learning_rate * dLdU\n",
    "    self.V -= learning_rate * dLdV\n",
    "    self.W -= learning_rate * dLdW\n",
    "RNNNumpy.sgd_step = numpy_sgd_step\n",
    "\n",
    "### 4.2. outer SGD loop\n",
    "'''\n",
    " - model: \n",
    " - X_train:\n",
    " - y_train:\n",
    " - learning_rate:\n",
    " - nepoch:\n",
    " - evaluate loss_after:\n",
    "'''\n",
    "def train_with_sgd(model, X_train, y_train, learning_rate = 0.005, nepoch = 100, evaluate_loss_after = 5):\n",
    "    # keep track of the losses so that we can plot them later\n",
    "    losses = []\n",
    "    num_examples_seen = 0\n",
    "    for epoch in range(nepoch):\n",
    "        # optionally evaluate the loss\n",
    "        if (epoch % evaluate_loss_after == 0):\n",
    "            loss = model.calculate_loss(X_train, y_train)\n",
    "            losses.append((num_examples_seen, loss))\n",
    "            time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n",
    "            print(\"%s: loss after num_examples_seen=%d epoch=%d: %f\" %(time, num_examples_seen, epoch, loss))\n",
    "            # adjust the learning rate if loss increases\n",
    "            if (len(losses) > 1 and losses[-1][1] > losses[-2][1]):\n",
    "                learning_rate = learning_rate * 0.5\n",
    "                print(\"setting learning rate to %f\" %(learning_rate))\n",
    "            sys.stdout.flush()\n",
    "        # for each training example...\n",
    "        for i in range(len(y_train)):\n",
    "            # one sgd step\n",
    "            model.sgd_step(X_train[i], y_train[i], learning_rate)\n",
    "            num_examples_seen += 1\n",
    "\n",
    "np.random.seed(10)\n",
    "model = RNNNumpy(vocab_size)\n",
    "%timeit model.sgd_step(traindata[10], testdata[10], 0.005)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def lstm_rnn(inputs, h, c, temperature=1.0):\n",
    "    outputs = []\n",
    "    for X in inputs:\n",
    "        g = nd.tanh(nd.dot(X, Wxg) + nd.dot(h, Whg) + bg)\n",
    "        i = nd.sigmoid(nd.dot(X, Wxi) + nd.dot(h, Whi) + bi)\n",
    "        f = nd.sigmoid(nd.dot(X, Wxf) + nd.dot(h, Whf) + bf)\n",
    "        o = nd.sigmoid(nd.dot(X, Wxo) + nd.dot(h, Who) + bo)\n",
    "        #######################\n",
    "        #\n",
    "        #######################\n",
    "        c = f * c + i * g\n",
    "        h = o * nd.tanh(c)\n",
    "        #######################\n",
    "        #\n",
    "        #######################\n",
    "        yhat_linear = nd.dot(h, Why) + by\n",
    "        yhat = softmax(yhat_linear, temperature=temperature)\n",
    "        outputs.append(yhat)\n",
    "    return (outputs, h, c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "Minimal character-level Vanilla RNN model. Written by Andrej Karpathy (@karpathy)\n",
    "BSD License\n",
    "\"\"\"\n",
    "import numpy as np\n",
    "\n",
    "# data I/O\n",
    "data = allBooks\n",
    "chars = list(set(data))\n",
    "data_size, vocab_size = len(data), len(chars)\n",
    "print('data has %d characters, %d unique.' % (data_size, vocab_size))\n",
    "char_to_ix = { ch:i for i,ch in enumerate(chars) }\n",
    "ix_to_char = { i:ch for i,ch in enumerate(chars) }\n",
    "\n",
    "# doubling and halving\n",
    "hidden_size = 100 # size of hidden layer of neurons\n",
    "seq_length = 25 # number of steps to unroll the RNN for\n",
    "learning_rate = 1e-1\n",
    "\n",
    "# model parameters\n",
    "Wxh = np.random.randn(hidden_size, vocab_size)*0.01 # input to hidden\n",
    "Whh = np.random.randn(hidden_size, hidden_size)*0.01 # hidden to hidden\n",
    "Why = np.random.randn(vocab_size, hidden_size)*0.01 # hidden to output\n",
    "bh = np.zeros((hidden_size, 1)) # hidden bias\n",
    "by = np.zeros((vocab_size, 1)) # output bias\n",
    "\n",
    "def lossFun(inputs, targets, hprev):\n",
    "  \"\"\"\n",
    "  inputs,targets are both list of integers.\n",
    "  hprev is Hx1 array of initial hidden state\n",
    "  returns the loss, gradients on model parameters, and last hidden state\n",
    "  \"\"\"\n",
    "  xs, hs, ys, ps = {}, {}, {}, {}\n",
    "  hs[-1] = np.copy(hprev)\n",
    "  loss = 0\n",
    "  # forward pass\n",
    "  for t in range(len(inputs)):\n",
    "    xs[t] = np.zeros((vocab_size,1)) # encode in 1-of-k representation\n",
    "    xs[t][inputs[t]] = 1\n",
    "    hs[t] = np.tanh(np.dot(Wxh, xs[t]) + np.dot(Whh, hs[t-1]) + bh) # hidden state\n",
    "    ys[t] = np.dot(Why, hs[t]) + by # unnormalized log probabilities for next chars\n",
    "    ps[t] = np.exp(ys[t]) / np.sum(np.exp(ys[t])) # probabilities for next chars\n",
    "    loss += -np.log(ps[t][targets[t],0]) # softmax (cross-entropy loss)\n",
    "  # backward pass: compute gradients going backwards\n",
    "  dWxh, dWhh, dWhy = np.zeros_like(Wxh), np.zeros_like(Whh), np.zeros_like(Why)\n",
    "  dbh, dby = np.zeros_like(bh), np.zeros_like(by)\n",
    "  dhnext = np.zeros_like(hs[0])\n",
    "  for t in reversed(range(len(inputs))):\n",
    "    dy = np.copy(ps[t])\n",
    "    dy[targets[t]] -= 1 # backprop into y. see http://cs231n.github.io/neural-networks-case-study/#grad if confused here\n",
    "    dWhy += np.dot(dy, hs[t].T)\n",
    "    dby += dy\n",
    "    dh = np.dot(Why.T, dy) + dhnext # backprop into h\n",
    "    dhraw = (1 - hs[t] * hs[t]) * dh # backprop through tanh nonlinearity\n",
    "    dbh += dhraw\n",
    "    dWxh += np.dot(dhraw, xs[t].T)\n",
    "    dWhh += np.dot(dhraw, hs[t-1].T)\n",
    "    dhnext = np.dot(Whh.T, dhraw)\n",
    "  for dparam in [dWxh, dWhh, dWhy, dbh, dby]:\n",
    "    np.clip(dparam, -5, 5, out=dparam) # clip to mitigate exploding gradients\n",
    "  return loss, dWxh, dWhh, dWhy, dbh, dby, hs[len(inputs)-1]\n",
    "\n",
    "def sample(h, seed_ix, n):\n",
    "  \"\"\" \n",
    "  sample a sequence of integers from the model \n",
    "  h is memory state, seed_ix is seed letter for first time step\n",
    "  \"\"\"\n",
    "  x = np.zeros((vocab_size, 1))\n",
    "  x[seed_ix] = 1\n",
    "  ixes = []\n",
    "  for t in range(n):\n",
    "    h = np.tanh(np.dot(Wxh, x) + np.dot(Whh, h) + bh)\n",
    "    y = np.dot(Why, h) + by\n",
    "    p = np.exp(y) / np.sum(np.exp(y))\n",
    "    ix = np.random.choice(range(vocab_size), p=p.ravel())\n",
    "    x = np.zeros((vocab_size, 1))\n",
    "    x[ix] = 1\n",
    "    ixes.append(ix)\n",
    "  return ixes\n",
    "all_losses = []\n",
    "n, p = 0, 0\n",
    "mWxh, mWhh, mWhy = np.zeros_like(Wxh), np.zeros_like(Whh), np.zeros_like(Why)\n",
    "mbh, mby = np.zeros_like(bh), np.zeros_like(by) # memory variables for Adagrad\n",
    "smooth_loss = -np.log(1.0/vocab_size)*seq_length # loss at iteration 0\n",
    "while True:\n",
    "  # prepare inputs (we're sweeping from left to right in steps seq_length long)\n",
    "  if p+seq_length+1 >= len(data) or n == 0: \n",
    "    hprev = np.zeros((hidden_size,1)) # reset RNN memory\n",
    "    p = 0 # go from start of data\n",
    "  inputs = [char_to_ix[ch] for ch in data[p:p+seq_length]]\n",
    "  targets = [char_to_ix[ch] for ch in data[p+1:p+seq_length+1]]\n",
    "  gradCheck(inputs, targets, hprev)\n",
    "\n",
    "  # sample from the model now and then\n",
    "  if n % 100 == 0:\n",
    "    sample_ix = sample(hprev, inputs[0], 200)\n",
    "    txt = ''.join(ix_to_char[ix] for ix in sample_ix)\n",
    "    print( '----\\n %s \\n----' % (txt, ))\n",
    "\n",
    "  # forward seq_length characters through the net and fetch gradient\n",
    "  loss, dWxh, dWhh, dWhy, dbh, dby, hprev = lossFun(inputs, targets, hprev)\n",
    "  smooth_loss = smooth_loss * 0.999 + loss * 0.001\n",
    "  if n in [1,20,50,60,100]: print( 'iter %d, loss: %f' % (n, smooth_loss)) # print progress\n",
    "  all_losses.append(smooth_loss)\n",
    "  # perform parameter update with Adagrad\n",
    "  for param, dparam, mem in zip([Wxh, Whh, Why, bh, by], \n",
    "                                [dWxh, dWhh, dWhy, dbh, dby], \n",
    "                                [mWxh, mWhh, mWhy, mbh, mby]):\n",
    "    mem += dparam * dparam\n",
    "    param += -learning_rate * dparam / np.sqrt(mem + 1e-8) # adagrad update\n",
    "\n",
    "  p += seq_length # move data pointer\n",
    "  n += 1 # iteration counter "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "Minimal character-level Vanilla RNN model. Written by Andrej Karpathy (@karpathy)\n",
    "BSD License\n",
    "\"\"\"\n",
    "import numpy as np\n",
    "\n",
    "# data I/O\n",
    "data = allBooks\n",
    "chars = list(set(data))\n",
    "data_size, vocab_size = len(data), len(chars)\n",
    "print('data has %d characters, %d unique.' % (data_size, vocab_size))\n",
    "char_to_ix = { ch:i for i,ch in enumerate(chars) }\n",
    "ix_to_char = { i:ch for i,ch in enumerate(chars) }\n",
    "\n",
    "# doubling and halving\n",
    "hidden_size = 100 # size of hidden layer of neurons\n",
    "seq_length = 25 # number of steps to unroll the RNN for\n",
    "learning_rate = 1e-1\n",
    "\n",
    "# model parameters\n",
    "Wxh = np.random.randn(hidden_size, vocab_size)*0.01 # input to hidden\n",
    "Whh = np.random.randn(hidden_size, hidden_size)*0.01 # hidden to hidden\n",
    "Why = np.random.randn(vocab_size, hidden_size)*0.01 # hidden to output\n",
    "bh = np.zeros((hidden_size, 1)) # hidden bias\n",
    "by = np.zeros((vocab_size, 1)) # output bias\n",
    "\n",
    "def lossFun(inputs, targets, hprev):\n",
    "  \"\"\"\n",
    "  inputs,targets are both list of integers.\n",
    "  hprev is Hx1 array of initial hidden state\n",
    "  returns the loss, gradients on model parameters, and last hidden state\n",
    "  \"\"\"\n",
    "  xs, hs, ys, ps = {}, {}, {}, {}\n",
    "  hs[-1] = np.copy(hprev)\n",
    "  loss = 0\n",
    "  # forward pass\n",
    "  for t in range(len(inputs)):\n",
    "    xs[t] = np.zeros((vocab_size,1)) # encode in 1-of-k representation\n",
    "    xs[t][inputs[t]] = 1\n",
    "    hs[t] = np.tanh(np.dot(Wxh, xs[t]) + np.dot(Whh, hs[t-1]) + bh) # hidden state\n",
    "    ys[t] = np.dot(Why, hs[t]) + by # unnormalized log probabilities for next chars\n",
    "    ps[t] = np.exp(ys[t]) / np.sum(np.exp(ys[t])) # probabilities for next chars\n",
    "    loss += -np.log(ps[t][targets[t],0]) # softmax (cross-entropy loss)\n",
    "  # backward pass: compute gradients going backwards\n",
    "  dWxh, dWhh, dWhy = np.zeros_like(Wxh), np.zeros_like(Whh), np.zeros_like(Why)\n",
    "  dbh, dby = np.zeros_like(bh), np.zeros_like(by)\n",
    "  dhnext = np.zeros_like(hs[0])\n",
    "  for t in reversed(range(len(inputs))):\n",
    "    dy = np.copy(ps[t])\n",
    "    dy[targets[t]] -= 1 # backprop into y. see http://cs231n.github.io/neural-networks-case-study/#grad if confused here\n",
    "    dWhy += np.dot(dy, hs[t].T)\n",
    "    dby += dy\n",
    "    dh = np.dot(Why.T, dy) + dhnext # backprop into h\n",
    "    dhraw = (1 - hs[t] * hs[t]) * dh # backprop through tanh nonlinearity\n",
    "    dbh += dhraw\n",
    "    dWxh += np.dot(dhraw, xs[t].T)\n",
    "    dWhh += np.dot(dhraw, hs[t-1].T)\n",
    "    dhnext = np.dot(Whh.T, dhraw)\n",
    "  for dparam in [dWxh, dWhh, dWhy, dbh, dby]:\n",
    "    np.clip(dparam, -5, 5, out=dparam) # clip to mitigate exploding gradients\n",
    "  return loss, dWxh, dWhh, dWhy, dbh, dby, hs[len(inputs)-1]\n",
    "\n",
    "def sample(h, seed_ix, n):\n",
    "  \"\"\" \n",
    "  sample a sequence of integers from the model \n",
    "  h is memory state, seed_ix is seed letter for first time step\n",
    "  \"\"\"\n",
    "  x = np.zeros((vocab_size, 1))\n",
    "  x[seed_ix] = 1\n",
    "  ixes = []\n",
    "  for t in range(n):\n",
    "    h = np.tanh(np.dot(Wxh, x) + np.dot(Whh, h) + bh)\n",
    "    y = np.dot(Why, h) + by\n",
    "    p = np.exp(y) / np.sum(np.exp(y))\n",
    "    ix = np.random.choice(range(vocab_size), p=p.ravel())\n",
    "    x = np.zeros((vocab_size, 1))\n",
    "    x[ix] = 1\n",
    "    ixes.append(ix)\n",
    "  return ixes\n",
    "all_losses = []\n",
    "n, p = 0, 0\n",
    "mWxh, mWhh, mWhy = np.zeros_like(Wxh), np.zeros_like(Whh), np.zeros_like(Why)\n",
    "mbh, mby = np.zeros_like(bh), np.zeros_like(by) # memory variables for Adagrad\n",
    "smooth_loss = -np.log(1.0/vocab_size)*seq_length # loss at iteration 0\n",
    "while True:\n",
    "  # prepare inputs (we're sweeping from left to right in steps seq_length long)\n",
    "  if p+seq_length+1 >= len(data) or n == 0: \n",
    "    hprev = np.zeros((hidden_size,1)) # reset RNN memory\n",
    "    p = 0 # go from start of data\n",
    "  inputs = [char_to_ix[ch] for ch in data[p:p+seq_length]]\n",
    "  targets = [char_to_ix[ch] for ch in data[p+1:p+seq_length+1]]\n",
    "  gradCheck(inputs, targets, hprev)\n",
    "\n",
    "  # sample from the model now and then\n",
    "  if n % 100 == 0:\n",
    "    sample_ix = sample(hprev, inputs[0], 200)\n",
    "    txt = ''.join(ix_to_char[ix] for ix in sample_ix)\n",
    "    print( '----\\n %s \\n----' % (txt, ))\n",
    "\n",
    "  # forward seq_length characters through the net and fetch gradient\n",
    "  loss, dWxh, dWhh, dWhy, dbh, dby, hprev = lossFun(inputs, targets, hprev)\n",
    "  smooth_loss = smooth_loss * 0.999 + loss * 0.001\n",
    "  if n in [1,20,50,60,100]: print( 'iter %d, loss: %f' % (n, smooth_loss)) # print progress\n",
    "  all_losses.append(smooth_loss)\n",
    "  # perform parameter update with Adagrad\n",
    "  for param, dparam, mem in zip([Wxh, Whh, Why, bh, by], \n",
    "                                [dWxh, dWhh, dWhy, dbh, dby], \n",
    "                                [mWxh, mWhh, mWhy, mbh, mby]):\n",
    "    mem += dparam * dparam\n",
    "    param += -learning_rate * dparam / np.sqrt(mem + 1e-8) # adagrad update\n",
    "\n",
    "  p += seq_length # move data pointer\n",
    "  n += 1 # iteration counter "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "plt.plot(range(len(all_losses)),all_losses)\n",
    "plt.xlabel(\"epoch\")\n",
    "plt.ylabel(\"loss\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# gradient checking\n",
    "from random import uniform\n",
    "def gradCheck(inputs, target, hprev):\n",
    "  global Wxh, Whh, Why, bh, by\n",
    "  num_checks, delta = 10, 1e-5\n",
    "  _, dWxh, dWhh, dWhy, dbh, dby, _ = lossFun(inputs, targets, hprev)\n",
    "  for param,dparam,name in zip([Wxh, Whh, Why, bh, by], [dWxh, dWhh, dWhy, dbh, dby], ['Wxh', 'Whh', 'Why', 'bh', 'by']):\n",
    "    s0 = dparam.shape\n",
    "    s1 = param.shape\n",
    "    assert s0 == s1\n",
    "    print(name)\n",
    "    for i in range(num_checks):\n",
    "      ri = int(uniform(0,param.size))\n",
    "      # evaluate cost at [x + delta] and [x - delta]\n",
    "      old_val = param.flat[ri]\n",
    "      param.flat[ri] = old_val + delta\n",
    "      cg0, _, _, _, _, _, _ = lossFun(inputs, targets, hprev)\n",
    "      param.flat[ri] = old_val - delta\n",
    "      cg1, _, _, _, _, _, _ = lossFun(inputs, targets, hprev)\n",
    "      param.flat[ri] = old_val # reset old value for this parameter\n",
    "      # fetch both numerical and analytic gradient\n",
    "      grad_analytic = dparam.flat[ri]\n",
    "      grad_numerical = (cg0 - cg1) / ( 2 * delta )\n",
    "      rel_error = abs(grad_analytic - grad_numerical) / abs(grad_numerical + grad_analytic)\n",
    "      print( '%f, %f => %e ' % (grad_numerical, grad_analytic, rel_error))\n",
    "      # rel_error should be on order of 1e-7 or less"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
